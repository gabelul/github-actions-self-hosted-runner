name: Version & Release

on:
  push:
    branches: [main]
    paths-ignore:
      - 'VERSION'
      - 'CHANGELOG.md'
      - '.github/workflows/version-release.yml'

permissions:
  contents: write
  pull-requests: write

jobs:
  version-and-release:
    name: Auto Version & Release
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for changelog generation
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get last version tag
        id: last-tag
        run: |
          # Get the last version tag
          last_tag=$(git tag -l "v*" | sort -V | tail -1)
          if [ -z "$last_tag" ]; then
            last_tag="v0.0.0"
          fi
          echo "tag=$last_tag" >> $GITHUB_OUTPUT
          echo "Last version tag: $last_tag"

      - name: Analyze commits and determine version bump
        id: version-bump
        run: |
          last_tag="${{ steps.last-tag.outputs.tag }}"

          # Get commits since last tag
          if [ "$last_tag" == "v0.0.0" ]; then
            commits=$(git log --pretty=format:"%s" HEAD)
          else
            commits=$(git log --pretty=format:"%s" $last_tag..HEAD)
          fi

          echo "Commits since $last_tag:"
          echo "$commits"
          echo ""

          # Determine bump type based on conventional commits
          bump_type="none"

          if echo "$commits" | grep -qiE "^(BREAKING CHANGE|breaking|major):"; then
            bump_type="major"
          elif echo "$commits" | grep -qiE "^(feat|feature):"; then
            bump_type="minor"
          elif echo "$commits" | grep -qiE "^(fix|bugfix|patch):"; then
            bump_type="patch"
          elif echo "$commits" | grep -qiE "^(chore|docs|style|refactor|test|ci):"; then
            bump_type="patch"
          fi

          echo "Bump type: $bump_type"
          echo "type=$bump_type" >> $GITHUB_OUTPUT

      - name: Calculate new version
        id: new-version
        if: steps.version-bump.outputs.type != 'none'
        run: |
          last_tag="${{ steps.last-tag.outputs.tag }}"
          bump_type="${{ steps.version-bump.outputs.type }}"

          # Remove 'v' prefix
          current_version="${last_tag#v}"

          # Split version into parts
          IFS='.' read -r major minor patch <<< "$current_version"

          # Bump version based on type
          case "$bump_type" in
            major)
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              ;;
            patch)
              patch=$((patch + 1))
              ;;
          esac

          new_version="$major.$minor.$patch"
          new_tag="v$new_version"

          echo "New version: $new_version"
          echo "New tag: $new_tag"

          echo "version=$new_version" >> $GITHUB_OUTPUT
          echo "tag=$new_tag" >> $GITHUB_OUTPUT

      - name: Generate changelog entry
        id: changelog
        if: steps.version-bump.outputs.type != 'none'
        run: |
          last_tag="${{ steps.last-tag.outputs.tag }}"
          new_version="${{ steps.new-version.outputs.version }}"

          # Get commits since last tag
          if [ "$last_tag" == "v0.0.0" ]; then
            commits=$(git log --pretty=format:"- %s (%h)" HEAD)
          else
            commits=$(git log --pretty=format:"- %s (%h)" $last_tag..HEAD)
          fi

          # Create changelog entry
          cat > /tmp/changelog_entry.md << EOF
          ## [$new_version] - $(date +%Y-%m-%d)

          ### Changes
          $commits

          EOF

          echo "Changelog entry created"
          cat /tmp/changelog_entry.md

      - name: Update VERSION file
        if: steps.version-bump.outputs.type != 'none'
        run: |
          new_version="${{ steps.new-version.outputs.version }}"
          echo "$new_version" > VERSION
          echo "Updated VERSION file to $new_version"

      - name: Update CHANGELOG.md
        if: steps.version-bump.outputs.type != 'none'
        run: |
          # Insert new changelog entry after the header
          if [ -f CHANGELOG.md ]; then
            # Find the line number after the header (after "## [")
            line_num=$(grep -n "^## \[" CHANGELOG.md | head -1 | cut -d: -f1)

            if [ -n "$line_num" ]; then
              # Insert before the first version entry
              head -n $((line_num - 1)) CHANGELOG.md > /tmp/changelog_new.md
              cat /tmp/changelog_entry.md >> /tmp/changelog_new.md
              tail -n +$line_num CHANGELOG.md >> /tmp/changelog_new.md
              mv /tmp/changelog_new.md CHANGELOG.md
            else
              # No existing entries, append after header
              echo "" >> CHANGELOG.md
              cat /tmp/changelog_entry.md >> CHANGELOG.md
            fi
          else
            # Create new CHANGELOG.md
            cat > CHANGELOG.md << 'EOF'
          # Changelog

          All notable changes to this project will be documented in this file.

          The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
          and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

          EOF
            cat /tmp/changelog_entry.md >> CHANGELOG.md
          fi

          echo "Updated CHANGELOG.md"

      - name: Commit version bump
        if: steps.version-bump.outputs.type != 'none'
        run: |
          new_tag="${{ steps.new-version.outputs.tag }}"

          git config user.name "Gabi"
          git config user.email "hola@booplex.com"

          git add VERSION CHANGELOG.md
          git commit -m "chore: bump version to $new_tag

          Automated version bump based on conventional commits"

          echo "Version bump committed"

      - name: Create and push tag
        if: steps.version-bump.outputs.type != 'none'
        run: |
          new_tag="${{ steps.new-version.outputs.tag }}"
          new_version="${{ steps.new-version.outputs.version }}"

          git tag -a "$new_tag" -m "Release $new_version"
          git push origin main
          git push origin "$new_tag"

          echo "Tag $new_tag created and pushed"

      - name: Generate release notes
        id: release-notes
        if: steps.version-bump.outputs.type != 'none'
        run: |
          last_tag="${{ steps.last-tag.outputs.tag }}"
          new_tag="${{ steps.new-version.outputs.tag }}"

          # Get all commits for release notes
          if [ "$last_tag" == "v0.0.0" ]; then
            commits=$(git log --pretty=format:"- %s (%h)" HEAD)
          else
            commits=$(git log --pretty=format:"- %s (%h)" $last_tag..HEAD)
          fi

          # Create release notes
          cat > /tmp/release_notes.md << EOF
          ## What's Changed

          $commits

          **Full Changelog**: https://github.com/${{ github.repository }}/compare/$last_tag...$new_tag
          EOF

          # Save to output
          {
            echo "notes<<EOF"
            cat /tmp/release_notes.md
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        if: steps.version-bump.outputs.type != 'none'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.new-version.outputs.tag }}
          name: Release ${{ steps.new-version.outputs.version }}
          body: ${{ steps.release-notes.outputs.notes }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: No version bump needed
        if: steps.version-bump.outputs.type == 'none'
        run: |
          echo "No version bump needed - no conventional commit patterns found"
          echo "Use prefixes like 'fix:', 'feat:', or 'BREAKING CHANGE:' to trigger versioning"